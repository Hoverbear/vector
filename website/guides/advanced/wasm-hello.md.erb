---
$schema: "/.meta/.schemas/guides.json"
title: Hello, WASM world
description: Write your first WASM plugin for Vector
author_github: https://github.com/hoverbear
tags: ["type: guide", "domain: transforms", "transform: wasm"]
---

<Assumptions name="guide">

* You understand the [basic Vector concepts][docs.about.concepts] and understand [how to set up a pipeline][guides.getting-started.your-first-pipeline].
* You have a configured development environment according to our [`CONTRIBUTING.md`][TODO] file.
* You must be using a Linux system (or subsystem for Windows users) for WASM related work right now.

</Assumptions>

Vector supports a robust, language agnostic WebAssembly runtime with WASI support. While support
matures, we encourage you to try out the transform and consider how it might fit into your pipelines.

First, let's talk a bit about them! Just want to dig in? [**Fastpath to Hacking!**][#Understanding-the-Current-Limitations]

## Why does Vector need plugins?

We had a few reasons to add plugin support!

**Build Complexity is first.** Vector connects sources to sinks -- With some transformation magic in between. The more **stuff** you support, the more Vector grows in size. Each component we add brings with it a new set of dependencies, increasing things like binary size, testing time, and linkage which need to be made and optimized.

Eventually, Vector will grow large enough that some folks won't be able to contribute to it, their computers won't be able to handle it. What a nightmare scenario ðŸ˜”. *Fear not. Plugins can help us.* They allow us to decompose Vector components into small units that don't need to be part of the main linkage.

**Language capabilities & limitations is up next.** Vector is built on Rust. It's a static, systems language which relies on ahead-of-time compilation. Normally, this is a most excellent decision, but in some niche cases it creates big problems! *Protobufs* are a good example of this problem. See, most fast protobuf libraries are *generated* by a tool called `protoc` or something like `prost`, a protobuf crate that generates code at build time.

This is not something Vector can do without adding a **lot** of dependencies. Normally in a situation like this, the best solution would be to work with the upstream ecosystem to come up with efficient runtime solutions. We tried this, and there was a path forward here, for protobufs. But we knew there were other formats like Avro or Cap'n Proto. This is a problem that would keep repeating. Plugins let our users go ahead and roll their own custom deserializers for any protocol they want, and we can build tooling to help them do that in a nice way.

**Lua, DSLs, and other configuration methods are so fun to use!** We found users really enjoy the feeling of using a language they're familiar with to use Vector. Our Lua transform is very popular, and we are often getting requests for other languages like Javascript.

WASM lets us solve this. By exposing a WASM interface, we can support any language that compiles to WASM. We hope this will let us provide a better, more familiar experience to users who like to write their own scripts.

## What's a WASM

WebAssembly (or WASM) is an execution format.

Compilers like `rustc` can output code into WebAssembly format (either binary `.wasm` or UTF-8 `.wat`). These are just like `.so` or `.dll` files you may have seen in your filesystem.

If you've specified a WASM module in your Vector config, Vector will go ahead and load it, then optimize the code for the exact machine it's running on. (This includes features like SSE3 and AVX!) (TODO: Validate) Vector then executes that code, and communicates with it through a foreign-function interface.

(TODO More)

## Why are Vector Plugins WASM based?

* Portability (cross arch)
* Portability (language target)
* Portability (cross OS)
* Security (Sandboxing)
* Security (Auditability)
* Performance (Low overhead)

## Cook your development environment & Vector builds

* Build Vector with WASM from the env.
* Demonstrate how to build, test, and bench the WASM modules Vector ships with.

## Hack on a Plugin

* Write your own plugin.
* Deploy it alongside Vector.
* Use it with Vector.

## Understanding the Current Limitations

* Timers
* Streaming
* Multi-input/output
